import Mathlib.Data.Nat.Bitwise
import Mathlib.Tactic.Find
import Aesop

namespace SegmentTree

-- Reference: https://cp-algorithms.com/data_structures/segment_tree.html#implementation

structure Range where
  l : Nat
  r: Nat
  lLeR : l <= r

def Range.contains (x: Nat) (range: Range) :Bool :=
    x >= range.l ∧ x <= range.r

-- Split the range such that they are definitely disjoint and valid
def Range.splitAt (rng: Range) (at': Nat) : Option Range × Option Range :=
    let ⟨ l', r', _ ⟩ := rng
    let m' := Nat.min r' at'
    let m'' := Nat.max l' (at' + 1)
    let fstRange := if h: l' <= m' then Option.some (Range.mk l' m' h ) else .none
    let sndRange := if h: m'' <= r' then Option.some (Range.mk m'' r' h) else .none
    ( fstRange, sndRange )


def Range.asList (rng: Range) :=
    match rng with
    | Range.mk l r h=> if h': l = r then [l] else (
        l::(asList (Range.mk ( l+1 ) r (by
          omega
          )))
      ) termination_by rng.r - rng.l

#eval ( Range.mk 0 10 (by simp) ).asList
#eval (
      let ⟨l,r⟩ := ( Range.mk 0 10 (by simp) ).splitAt 5
      let l' :=  ( l.map Range.asList ).getD [] 
      let r' := (r.map Range.asList).getD []
      l' ++ r'
    )

def combinedRangesAsList (rngs: Option Range × Option Range)  :=
      let ⟨l,r⟩ := rngs
      let l' :=  ( l.map Range.asList ).getD [] 
      let r' := (r.map Range.asList).getD []
      l' ++ r'

-- This is clearly true , so I'm going to treat this as an axiom,
-- I can definitely prove this but I think this is going to be lengthy
-- If there's a value idx that lies between l and r,
-- then (l, idx) ++ (idx+1,r)  = (l,r)
axiom exactlydisjointRangeAtIdxCombination: ∀ (idx: Nat) (rng: Range),
      (lLeIdx : rng.l <= idx) ->
      (idxSuccLeR: idx+1 <= rng.r) ->
      (Range.mk rng.l idx lLeIdx).asList ++ (Range.mk (idx+1) rng.r idxSuccLeR).asList  = rng.asList 


#find ?a <= ?b -> ?b <= ?a -> ?a = ?b

def Range.splitInvariant : ∀ (idx: Nat) (rng: Range), combinedRangesAsList (splitAt rng idx) = rng.asList := by
    intro idx rng
    unfold splitAt
    unfold Nat.min
    unfold Nat.max
    cases rng
    case mk l' r' h  =>
         simp_all
         unfold combinedRangesAsList
         simp_all
         rw [Nat.max_def]
         rw [Nat.min_def]
         -- aesop? -- The below part most of it is generated by aesop (thanks)
         split
         next h_1 =>
           simp_all only [Option.getD_some, List.append_right_eq_self]
           split
           next h_2 =>
             split
             next h_3 =>
               simp_all only [Option.getD_some]
               omega
             next h_3 => simp_all only [not_le, Option.getD_none]
           next h_2 =>
             simp_all only [Option.getD_some]
             omega
         next h_1 =>
           split
           next h_2 =>
             simp_all only [Option.getD_some]
             have h'':  l' <= idx + 1 := Nat.le_succ_of_le h_2
             simp [h'']
             rw [Nat.not_le] at h_1
             have h''':  idx + 1 <= r' := Nat.succ_le_of_lt h_1
             simp [h''']
             exact (exactlydisjointRangeAtIdxCombination idx (Range.mk l' r' _) h_2 h''')
           next h_2 =>
             simp_all only [not_le, Option.getD_none, List.nil_append]
             split
             next h_3 =>
               split
               next h_4 =>
                 simp_all only [Option.getD_some]
                 have h' : idx + 1 <= l'  := Nat.succ_le_of_lt h_2
                 have h'' : idx + 1 = l' := Nat.le_antisymm h' h_3
                 subst h''
                 rfl
               next h_4 =>
                 simp_all only [not_le, Option.getD_none, List.nil_eq]
                 omega
             next h_3 => simp_all only [Option.getD_some]
           
         






def mid (l r : Nat) :=
    Nat.div2 (l+r)


theorem lPlusRAtleast2l : (h: l <= r) -> l <= (l + r) / 2 := by
        omega

theorem lrMidLtR (h: l <= r) (h': ¬ (l = r)) : mid l r < r := by
    have h'' := Nat.lt_of_le_of_ne h h'
    unfold mid
    rw [Nat.div2_val]
    omega

theorem lLeMidLR : (h: l <= r) -> l <= mid l r := by
    intro h
    unfold mid
    rw [Nat.div2_val]
    apply lPlusRAtleast2l
    assumption


inductive SegTree : Range -> Type where
    | leaf l {r} {h: l = r} (val: Int) : SegTree (Range.mk l r (by omega))
    | node l r lLeR (lNeR: ¬ l = r) (val: Int) (left: SegTree (Range.mk l (mid l r) (by
      exact lLeMidLR lLeR
    ))) (right: SegTree (Range.mk (Nat.min r ((mid l r) + 1 )) r (by
        unfold Nat.min
        apply Nat.min_le_left
    ) )) : SegTree (Range.mk l r lLeR)

def SegTree.sum (seg: SegTree rng) (desiredRange: Range) : Int :=
    match seg with
    | .leaf l v => if desiredRange.contains l then v else 0
    | .node l r lLeR _ v leftSubtree rightSubtree =>
        let ⟨a,b, _⟩ := desiredRange
        if desiredRange.contains l ∧ desiredRange.contains r then 
          v
        else if r < a || l > b then 
          0
        else
          let m := Nat.div2 (l+r)
          let ⟨lRange,rRange⟩ := desiredRange.splitAt m
          ( match lRange, rRange with
          | Option.some leftRange, Option.some rightRange => sum leftSubtree leftRange  + sum rightSubtree rightRange
          | Option.some leftRange , Option.none => sum leftSubtree leftRange
          | Option.none , Option.some rightRange=> sum rightSubtree rightRange
          | Option.none , Option.none => 0 )

def SegTree.pointQuery (seg: SegTree rng) (idx:Nat) :=
    seg.sum (Range.mk idx idx (by simp))

private def SegTree.getVal (seg:SegTree rng) :=
    match seg with
    | .leaf _ v => v
    | .node _ _ _ _ v _ _ => v


def SegTree.invariant (seg: SegTree rng)  :=
  match seg with
  | .leaf _ _ => True  
  | .node _ _ _ _ val left right => 
      val = SegTree.getVal left + SegTree.getVal right ∧
      SegTree.invariant left ∧ SegTree.invariant right

def SegTree.update {rng: Range} (seg: SegTree rng) (idx: Nat) (newVal: Int) : SegTree rng :=
    match seg with
    | @SegTree.leaf l r h v => if l = idx then @SegTree.leaf l r h newVal else @SegTree.leaf l r h v
    | .node l r lLeR lNeR v leftSubtree rightSubtree =>
        if l <= idx && idx <= r then
          let m := mid l r
          if idx <= m then
            let newLeft := update leftSubtree idx newVal
            let newVal := getVal (newLeft) + getVal rightSubtree
            .node l r lLeR lNeR newVal newLeft rightSubtree
          else
            let newRight := update rightSubtree idx newVal
            let newVal := getVal leftSubtree + getVal newRight
            .node l r lLeR lNeR newVal leftSubtree newRight
        else
          -- Index outside of current range, no update needed
          .node l r lLeR lNeR v leftSubtree rightSubtree

theorem SegTree.updatePreservesInvariant : ∀ (rng: Range) ( seg: SegTree rng ) ,
        seg.invariant -> ∀ ( idx: Nat ) ( newVal: Int ), (seg.update idx newVal).invariant := by
      intro rng seg
      induction seg with
      | @leaf l r h v =>
        intro inv idx newVal
        unfold SegTree.update
        by_cases h': l = idx <;> (simp [h']; exact inv)
      | node l r lLeR lNeR val left right ihLeft ihRight  =>
          intro inv idx newVal
          have ⟨ valInv, lInv, rInv ⟩ := inv
          unfold SegTree.update
          by_cases h': (decide (l ≤ idx) && decide (idx ≤ r)) = true <;> simp [h']
          · by_cases h'': (idx <= mid l r) <;> (simp [h''])
            · have ihLeft' := ihLeft lInv idx newVal
              let left' := left.update idx newVal
              trivial
            · have ihRight' := ihRight rInv idx newVal
              let right':= right.update idx newVal
              trivial
          · trivial


#find ?a <= ?b -> ¬ ?a = ?b -> ?a < ?b
#find ?a > ?b -> ?c - ?a < ?c - ?b

private def mkWith0' (l: Nat) (r: Nat) (h: l <= r) : SegTree (Range.mk l r h) :=
    if h': l = r then (@SegTree.leaf l r h' 0)
    else (
            have lPlusRDecreases : mid l r < r := by
                 exact (lrMidLtR h h')
                 
            have midLRPlus1LeR : mid l r + 1 <= r := by
                 rw [Nat.succ_le_iff]
                 exact lPlusRDecreases

            have terminationCond : r - r.min (mid l r + 1) < r - l := by
                 have h''' := lLeMidLR h
                 apply Nat.sub_lt_sub_left
                 · omega 
                 · unfold mid at *
                   rw [Nat.div2_val] at *
                   unfold Nat.min
                   rw [Nat.min_def]
                   by_cases h'' : r <= ( (l+r) / 2 + 1 )
                   { simp [h''] ; omega }
                   { simp [h''] ; omega }

            let left := mkWith0' l (mid l r) ( by
                exact (lLeMidLR h)
            )
            let right := mkWith0' (r.min ((mid l r) +1)) r (by
                unfold mid at *
                rw [Nat.div2_val] at *
                unfold Nat.min
                rw [Nat.min_def]
                by_cases h'' : r <= ( (l+r) / 2 + 1 )
                { simp [h''] }
                { simp [h'']; omega }
            )
            .node l r h h' 0 left right
    )
    termination_by r - l

def SegTree.mkWith0 (len: Nat) : SegTree (Range.mk 0 len (by simp)) :=
    mkWith0' 0 len (by simp)

def SegTree.toArray (seg: SegTree rng) : Array Int :=
  match rng with
  | Range.mk l r _ =>
      let size := r - l
      let arr := mkArray size 0
      (List.range size).foldl (fun a i => 
        a.set! i (SegTree.pointQuery seg (i+l))) arr

def SegTree.fromArray (arr: Array Int) :=
    let segTree := SegTree.mkWith0 (arr.size)
    Prod.fst (arr.foldl (fun ⟨segTree', idx⟩ elem =>
          ( segTree'.update idx elem, idx + 1 )
    ) (segTree, 0))


section Example

  #eval (SegTree.fromArray #[1,2,3,4,5]).toArray 

  -- Generated by sir Claude
  --
  --
  -- Manually construct a segment tree for array [1, 3, 5, 7, 9]
  -- Structure will be:
  --                  [0-4] (sum: 25)
  --                 /          \
  --        [0-2] (sum: 9)     [3-4] (sum: 16)
  --        /         \        /       \
  --  [0-1] (sum: 4)  [2] (5) [3] (7)  [4] (9)
  --  /      \
  -- [0](1)  [1](3)
  
  -- Leaf nodes for indices 0 to 4
  def leaf0 : SegTree (Range.mk 0 0 (by simp)) := @SegTree.leaf 0 0 (by rfl) 1
  def leaf1 : SegTree (Range.mk 1 1 (by simp)) := @SegTree.leaf 1 1 (by rfl) 3
  def leaf2 : SegTree (Range.mk 2 2 (by simp)) := @SegTree.leaf 2 2 (by rfl) 5
  def leaf3 : SegTree (Range.mk 3 3 (by simp)) := @SegTree.leaf 3 3 (by rfl) 7
  def leaf4 : SegTree (Range.mk 4 4 (by simp)) := @SegTree.leaf 4 4 (by rfl) 9
  
  -- Internal node for indices 0 and 1 (sum = 4)
  def node01 : SegTree (Range.mk 0 1 (by simp)) := 
    SegTree.node 0 1 (by simp) (by simp) 4 leaf0 leaf1
  
  -- Internal node for indices 3 and 4 (sum = 16)
  def node34 : SegTree (Range.mk 3 4 (by simp)) := 
    SegTree.node 3 4 (by simp) (by simp) 16 leaf3 leaf4
  
  -- Internal node for indices 0, 1, and 2 (sum = 9)
  def node02 : SegTree (Range.mk 0 2 (by simp)) := 
    SegTree.node 0 2 (by simp) (by simp)  9 node01 leaf2
  
  -- Root node 
  def exampleTree : SegTree (Range.mk 0 4 (by simp)) := 
    SegTree.node 0 4 (by simp) (by simp) 25 node02 node34

  #eval SegTree.sum node34 (Range.mk 0 2 (by simp)) -- nothing since it's out of range
  #eval SegTree.toArray exampleTree

  #eval SegTree.sum exampleTree (Range.mk 0 2 (by simp))   -- Sum of [1, 3, 5] = 9
  #eval SegTree.sum exampleTree (Range.mk 1 3 (by simp))   -- Sum of [3, 5, 7] = 15
  #eval SegTree.sum exampleTree (Range.mk 0 4 (by simp))   -- Entire array sum= 25
  #eval SegTree.sum exampleTree (Range.mk 0 0 (by simp))   -- Single element = 1
  #eval SegTree.sum exampleTree (Range.mk 1 1 (by simp))   -- Single element = 3
  #eval SegTree.sum exampleTree (Range.mk 2 2 (by simp))   -- Single element = 5
  #eval SegTree.sum exampleTree (Range.mk 3 3 (by simp))   -- Single element = 7
  #eval SegTree.sum exampleTree (Range.mk 4 4 (by simp))   -- Single element = 9
  
  
  def updatedTree1 := SegTree.update exampleTree 2 10  -- => [1,3,10,7,9]
  #eval SegTree.toArray updatedTree1
  
  #eval SegTree.sum updatedTree1 (Range.mk 0 2 (by simp))   -- 14
  #eval SegTree.sum updatedTree1 (Range.mk 0 4 (by simp))   -- 30
  
  def updatedTree2 := SegTree.update updatedTree1 0 5   -- => [5,3,10,7,9]
  def updatedTree3 := SegTree.update updatedTree2 4 15  -- => [5,3,10,7,15]

  #eval SegTree.toArray updatedTree3
  #eval SegTree.sum updatedTree3 (Range.mk 0 4 (by simp))   -- 40
  #eval SegTree.sum updatedTree3 (Range.mk 3 4 (by simp))   -- sum( [7, 15] ) = 22
  #eval SegTree.sum updatedTree3 (Range.mk 0 0 (by simp))   -- 5
  #eval SegTree.sum updatedTree3 (Range.mk 4 4 (by simp))   -- 15

end Example

end SegmentTree
